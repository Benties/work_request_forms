{"ast":null,"code":"// QuickBase API configuration\nconst QB_API_URL = 'https://api.quickbase.com/v1';\nconst QB_APP_TOKEN = \"dwzpakaksstaqdqjwgbzbfypbpx\";\nconst QB_REALM_HOSTNAME = window.QUICKBASE_REALM;\nconst QB_DBID = 'buzzytkvg';\n\n// Headers for QuickBase API requests\nconst getHeaders = temporaryToken => ({\n  'QB-Realm-Hostname': QB_REALM_HOSTNAME,\n  'User-Agent': 'QuestionAnswerPlatform/1.0',\n  'Authorization': `QB-TEMP-TOKEN ${temporaryToken}`,\n  'Content-Type': 'application/json'\n});\n\n// Function to get temporary token\nconst getTemporaryToken = async () => {\n  try {\n    const response = await fetch(`${QB_API_URL}/auth/temporary/${QB_DBID}`, {\n      method: 'GET',\n      headers: {\n        'QB-Realm-Hostname': QB_REALM_HOSTNAME,\n        'User-Agent': 'QuestionAnswerPlatform/1.0',\n        'QB-App-Token': QB_APP_TOKEN,\n        'Content-Type': 'application/json'\n      },\n      credentials: 'include'\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to get temporary token');\n    }\n    const data = await response.json();\n    return data.temporaryAuthorization;\n  } catch (error) {\n    console.error('Error getting temporary token:', error);\n    throw error;\n  }\n};\n\n// Table IDs - Replace these with your actual QuickBase table IDs\nexport const TABLES = {\n  QUESTIONS: 'buzzze3pn',\n  ANSWERS: 'buzzzhvkj',\n  ATTACHMENTS: 'buz3i82er'\n};\n\n// Field IDs mapping by table\nexport const FIELDS = {\n  QUESTIONS: {\n    RECORD_ID: 3,\n    QUESTION: 6,\n    REQUIRED: 7,\n    FORM_ID: 10\n  },\n  ANSWERS: {\n    RECORD_ID: 3,\n    QUESTION_ID: 10,\n    ANSWER: 6,\n    USER_ID: 7,\n    USER_EMAIL: 8,\n    REQUEST_ID: 12\n  },\n  ATTACHMENTS: {\n    RECORD_ID: 3,\n    ANSWER_ID: 6,\n    FILE_ATTACHMENT: 7\n  }\n};\n\n// Types for file attachment data\n\n// API functions\nexport const api = {\n  // Get all active questions for a specific form\n  getQuestions: async formId => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.FORM_ID}.EX.'${formId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch questions');\n    }\n    return response.json();\n  },\n  // Get a single question\n  getQuestion: async questionId => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.RECORD_ID}.EX.'${questionId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch question');\n    }\n    return response.json();\n  },\n  // Get an answer for a specific question and request\n  getAnswer: async (questionId, requestId) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.RECORD_ID, FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.USER_EMAIL, FIELDS.ANSWERS.USER_ID],\n        where: `{${FIELDS.ANSWERS.QUESTION_ID}.EX.'${questionId}'}AND{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch answer');\n    }\n    return response.json();\n  },\n  // Save an answer\n  saveAnswer: async (questionId, answer, userId, requestId) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.QUESTION_ID]: {\n            value: questionId\n          },\n          [FIELDS.ANSWERS.ANSWER]: {\n            value: answer\n          },\n          [FIELDS.ANSWERS.USER_ID]: {\n            value: userId\n          },\n          [FIELDS.ANSWERS.REQUEST_ID]: {\n            value: requestId\n          }\n        }]\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to save answer');\n    }\n    return response.json();\n  },\n  // Get user's progress\n  getProgress: async requestId => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.QUESTION_ID],\n        where: `{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch progress');\n    }\n    return response.json();\n  },\n  // Update an existing answer\n  updateAnswer: async (answerId, answer, userId, requestId) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.RECORD_ID]: {\n            value: answerId\n          },\n          [FIELDS.ANSWERS.ANSWER]: {\n            value: answer\n          },\n          [FIELDS.ANSWERS.USER_ID]: {\n            value: userId\n          },\n          [FIELDS.ANSWERS.REQUEST_ID]: {\n            value: requestId\n          }\n        }]\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to update answer');\n    }\n    return response.json();\n  },\n  // Get file attachment\n  getFileAttachment: async recordId => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      const response = await fetch(`${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}`, {\n        method: 'GET',\n        headers: getHeaders(temporaryToken)\n      });\n      if (!response.ok) throw new Error('Failed to fetch file attachment');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching file attachment:', error);\n      throw error;\n    }\n  },\n  // Get attachments for an answer\n  getAttachmentsForAnswer: async answerId => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      const response = await fetch(`${QB_API_URL}/records/query`, {\n        method: 'POST',\n        headers: getHeaders(temporaryToken),\n        body: JSON.stringify({\n          from: TABLES.ATTACHMENTS,\n          select: [FIELDS.ATTACHMENTS.RECORD_ID, FIELDS.ATTACHMENTS.FILE_ATTACHMENT, 8],\n          where: `{${FIELDS.ATTACHMENTS.ANSWER_ID}.EX.'${answerId}'}`\n        })\n      });\n      if (!response.ok) throw new Error('Failed to fetch attachments');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching attachments:', error);\n      throw error;\n    }\n  },\n  // Upload or update file attachment\n  uploadFileAttachment: async (answerId, fileName, fileContent, recordId) => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      // Convert file content to Base64 if it's a File object\n      let base64Content;\n      if (fileContent instanceof File) {\n        const buffer = await fileContent.arrayBuffer();\n        base64Content = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n      } else {\n        base64Content = fileContent; // Assume it's already Base64 encoded if it's a string\n      }\n      const data = {\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          ...(recordId && {\n            [FIELDS.ATTACHMENTS.RECORD_ID]: {\n              value: recordId\n            }\n          }),\n          [FIELDS.ATTACHMENTS.FILE_ATTACHMENT]: {\n            value: {\n              fileName,\n              data: base64Content\n            }\n          },\n          [FIELDS.ATTACHMENTS.ANSWER_ID]: {\n            value: answerId\n          }\n        }]\n      };\n      const response = await fetch(`${QB_API_URL}/records`, {\n        method: 'POST',\n        headers: getHeaders(temporaryToken),\n        body: JSON.stringify(data)\n      });\n      if (!response.ok) throw new Error('Failed to upload file attachment');\n    } catch (error) {\n      console.error('Error uploading file attachment:', error);\n      throw error;\n    }\n  },\n  // Download file attachment\n  downloadFileAttachment: async url => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      var _contentDisposition$s;\n      const response = await fetch(`${QB_API_URL}${url}`, {\n        method: 'GET',\n        headers: getHeaders(temporaryToken)\n      });\n      if (!response.ok) throw new Error('Failed to download file attachment');\n      const contentDisposition = response.headers.get('Content-Disposition');\n      const fileName = (contentDisposition === null || contentDisposition === void 0 ? void 0 : (_contentDisposition$s = contentDisposition.split('filename=')[1]) === null || _contentDisposition$s === void 0 ? void 0 : _contentDisposition$s.replace(/\"/g, '')) || 'downloaded_file';\n      const content = await response.text(); // Base64 encoded content\n      return {\n        fileName,\n        content\n      };\n    } catch (error) {\n      console.error('Error downloading file attachment:', error);\n      throw error;\n    }\n  },\n  // Delete an attachment\n  deleteAttachment: async recordId => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'DELETE',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.ATTACHMENTS,\n        where: `{${FIELDS.ATTACHMENTS.RECORD_ID}.EX.'${recordId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to delete attachment');\n    }\n    return response.json();\n  },\n  createWorkRequest: async (subject, priority) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        to: 'buzzytkvk',\n        data: [{\n          '6': {\n            value: subject\n          },\n          '36': {\n            value: priority\n          }\n        }],\n        fieldsToReturn: [3, 32, 4]\n      })\n    });\n    if (!response.ok) {\n      throw new Error('Failed to create work request');\n    }\n    return response.json();\n  }\n};","map":{"version":3,"names":["QB_API_URL","QB_APP_TOKEN","QB_REALM_HOSTNAME","window","QUICKBASE_REALM","QB_DBID","getHeaders","temporaryToken","getTemporaryToken","response","fetch","method","headers","credentials","ok","error","json","Error","message","data","temporaryAuthorization","console","TABLES","QUESTIONS","ANSWERS","ATTACHMENTS","FIELDS","RECORD_ID","QUESTION","REQUIRED","FORM_ID","QUESTION_ID","ANSWER","USER_ID","USER_EMAIL","REQUEST_ID","ANSWER_ID","FILE_ATTACHMENT","api","getQuestions","formId","body","JSON","stringify","from","select","where","getQuestion","questionId","getAnswer","requestId","saveAnswer","answer","userId","to","value","getProgress","updateAnswer","answerId","getFileAttachment","recordId","getAttachmentsForAnswer","uploadFileAttachment","fileName","fileContent","base64Content","File","buffer","arrayBuffer","btoa","String","fromCharCode","Uint8Array","downloadFileAttachment","url","_contentDisposition$s","contentDisposition","get","split","replace","content","text","deleteAttachment","createWorkRequest","subject","priority","fieldsToReturn"],"sources":["/home/ben/lighthouse/work_requsts/frontend/src/config/quickbase.ts"],"sourcesContent":["// QuickBase API configuration\nconst QB_API_URL = 'https://api.quickbase.com/v1';\nconst QB_APP_TOKEN = \"dwzpakaksstaqdqjwgbzbfypbpx\";\nconst QB_REALM_HOSTNAME = window.QUICKBASE_REALM;\nconst QB_DBID = 'buzzytkvg';\n\n// Headers for QuickBase API requests\nconst getHeaders = (temporaryToken?: string) => ({\n  'QB-Realm-Hostname': QB_REALM_HOSTNAME,\n  'User-Agent': 'QuestionAnswerPlatform/1.0',\n  'Authorization': `QB-TEMP-TOKEN ${temporaryToken}`,\n  'Content-Type': 'application/json'\n})\n\n// Function to get temporary token\nconst getTemporaryToken = async () => {\n  try {\n    const response = await fetch(`${QB_API_URL}/auth/temporary/${QB_DBID}`, {\n      method: 'GET',\n      headers: {\n        'QB-Realm-Hostname': QB_REALM_HOSTNAME,\n        'User-Agent': 'QuestionAnswerPlatform/1.0',\n        'QB-App-Token': QB_APP_TOKEN,\n        'Content-Type': 'application/json'\n      },\n      credentials: 'include'\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to get temporary token');\n    }\n\n    const data = await response.json();\n    return data.temporaryAuthorization;\n  } catch (error) {\n    console.error('Error getting temporary token:', error);\n    throw error;\n  }\n};\n\n// Table IDs - Replace these with your actual QuickBase table IDs\nexport const TABLES = {\n  QUESTIONS: 'buzzze3pn',\n  ANSWERS: 'buzzzhvkj',\n  ATTACHMENTS: 'buz3i82er'\n};\n\n// Field IDs mapping by table\nexport const FIELDS = {\n  QUESTIONS: {\n    RECORD_ID: 3,\n    QUESTION: 6,\n    REQUIRED: 7,\n    FORM_ID: 10\n  },\n  ANSWERS: {\n    RECORD_ID: 3,\n    QUESTION_ID: 10,\n    ANSWER: 6,\n    USER_ID: 7,\n    USER_EMAIL: 8,\n    REQUEST_ID: 12,\n  },\n  ATTACHMENTS: {\n    RECORD_ID: 3,\n    ANSWER_ID: 6,\n    FILE_ATTACHMENT: 7\n  }\n};\n\n// Types for file attachment data\ninterface FileVersion {\n  versionNumber: number;\n  fileName: string;\n  uploaded: string;\n  creator: {\n    email: string;\n    id: string;\n    name: string;\n    userName: string;\n  };\n}\n\ninterface FileAttachment {\n  url: string;\n  reservedBy?: {\n    email: string;\n    id: string;\n    name: string;\n    userName: string;\n  };\n  versions: FileVersion[];\n}\n\ninterface FileAttachmentValue {\n  value: FileAttachment;\n}\n\ninterface Attachment {\n  record_id: number;\n  [key: number]: {\n    value: number | {\n      url: string;\n      versions: Array<{\n        creator: {\n          email: string;\n          id: string;\n          name: string;\n          userName: string;\n        };\n        fileName: string;\n        uploaded: string;\n        versionNumber: number;\n      }>;\n    };\n  };\n}\n\n// API functions\nexport const api = {\n  // Get all active questions for a specific form\n  getQuestions: async (formId: string) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.FORM_ID}.EX.'${formId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch questions');\n    }\n\n    return response.json();\n  },\n\n  // Get a single question\n  getQuestion: async (questionId: string) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.RECORD_ID}.EX.'${questionId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch question');\n    }\n\n    return response.json();\n  },\n\n  // Get an answer for a specific question and request\n  getAnswer: async (questionId: string, requestId: string) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.RECORD_ID, FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.USER_EMAIL, FIELDS.ANSWERS.USER_ID],\n        where: `{${FIELDS.ANSWERS.QUESTION_ID}.EX.'${questionId}'}AND{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch answer');\n    }\n\n    return response.json();\n  },\n\n  // Save an answer\n  saveAnswer: async (questionId: string, answer: string, userId: string, requestId: string) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.QUESTION_ID]: { value: questionId },\n          [FIELDS.ANSWERS.ANSWER]: { value: answer },\n          [FIELDS.ANSWERS.USER_ID]: { value: userId },\n          [FIELDS.ANSWERS.REQUEST_ID]: { value: requestId }\n        }]\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to save answer');\n    }\n\n    return response.json();\n  },\n\n  // Get user's progress\n  getProgress: async (requestId: string) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.QUESTION_ID],\n        where: `{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch progress');\n    }\n\n    return response.json();\n  },\n\n  // Update an existing answer\n  updateAnswer: async (answerId: string, answer: string, userId: string, requestId: string) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.RECORD_ID]: { value: answerId },\n          [FIELDS.ANSWERS.ANSWER]: { value: answer },\n          [FIELDS.ANSWERS.USER_ID]: { value: userId },\n          [FIELDS.ANSWERS.REQUEST_ID]: { value: requestId }\n        }]\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to update answer');\n    }\n\n    return response.json();\n  },\n\n  // Get file attachment\n  getFileAttachment: async (recordId: number): Promise<FileAttachmentValue> => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      const response = await fetch(`${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}`, {\n        method: 'GET',\n        headers: getHeaders(temporaryToken)\n      });\n      if (!response.ok) throw new Error('Failed to fetch file attachment');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching file attachment:', error);\n      throw error;\n    }\n  },\n\n  // Get attachments for an answer\n  getAttachmentsForAnswer: async (answerId: number): Promise<{ data: Attachment[] }> => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      const response = await fetch(`${QB_API_URL}/records/query`, {\n        method: 'POST',\n        headers: getHeaders(temporaryToken),\n        body: JSON.stringify({\n          from: TABLES.ATTACHMENTS,\n          select: [FIELDS.ATTACHMENTS.RECORD_ID, FIELDS.ATTACHMENTS.FILE_ATTACHMENT, 8],\n          where: `{${FIELDS.ATTACHMENTS.ANSWER_ID}.EX.'${answerId}'}`\n        })\n      });\n\n      if (!response.ok) throw new Error('Failed to fetch attachments');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching attachments:', error);\n      throw error;\n    }\n  },\n\n  // Upload or update file attachment\n  uploadFileAttachment: async (answerId: number, fileName: string, fileContent: string | File, recordId?: number): Promise<void> => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      // Convert file content to Base64 if it's a File object\n      let base64Content: string;\n      if (fileContent instanceof File) {\n        const buffer = await fileContent.arrayBuffer();\n        base64Content = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n      } else {\n        base64Content = fileContent; // Assume it's already Base64 encoded if it's a string\n      }\n\n      const data = {\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          ...(recordId && { [FIELDS.ATTACHMENTS.RECORD_ID]: { value: recordId } }),\n          [FIELDS.ATTACHMENTS.FILE_ATTACHMENT]: {\n            value: {\n              fileName,\n              data: base64Content\n            }\n          },\n          [FIELDS.ATTACHMENTS.ANSWER_ID]: { value: answerId }\n        }]\n      };\n\n      const response = await fetch(`${QB_API_URL}/records`, {\n        method: 'POST',\n        headers: getHeaders(temporaryToken),\n        body: JSON.stringify(data)\n      });\n\n      if (!response.ok) throw new Error('Failed to upload file attachment');\n    } catch (error) {\n      console.error('Error uploading file attachment:', error);\n      throw error;\n    }\n  },\n\n  // Download file attachment\n  downloadFileAttachment: async (url: string): Promise<{ fileName: string; content: string }> => {\n    const temporaryToken = await getTemporaryToken();\n    try {\n      const response = await fetch(`${QB_API_URL}${url}`, {\n        method: 'GET',\n        headers: getHeaders(temporaryToken)\n      });\n\n      if (!response.ok) throw new Error('Failed to download file attachment');\n\n      const contentDisposition = response.headers.get('Content-Disposition');\n      const fileName = contentDisposition?.split('filename=')[1]?.replace(/\"/g, '') || 'downloaded_file';\n\n      const content = await response.text(); // Base64 encoded content\n      return { fileName, content };\n    } catch (error) {\n      console.error('Error downloading file attachment:', error);\n      throw error;\n    }\n  },\n\n  // Delete an attachment\n  deleteAttachment: async (recordId: number) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'DELETE',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        from: TABLES.ATTACHMENTS,\n        where: `{${FIELDS.ATTACHMENTS.RECORD_ID}.EX.'${recordId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to delete attachment');\n    }\n\n    return response.json();\n  },\n\n  createWorkRequest: async (subject: string, priority: string) => {\n    const temporaryToken = await getTemporaryToken();\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(temporaryToken),\n      body: JSON.stringify({\n        to: 'buzzytkvk',\n        data: [\n          {\n            '6': { value: subject },\n            '36': { value: priority }\n          }\n        ],\n        fieldsToReturn: [3, 32, 4]\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to create work request');\n    }\n\n    return response.json();\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}