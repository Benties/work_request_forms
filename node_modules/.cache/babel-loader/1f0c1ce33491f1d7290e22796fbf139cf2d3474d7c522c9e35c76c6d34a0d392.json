{"ast":null,"code":"// QuickBase API configuration\nconst QB_API_URL = 'https://api.quickbase.com/v1';\n\n// Headers for QuickBase API requests\nconst getHeaders = () => ({\n  'QB-Realm-Hostname': window.QUICKBASE_REALM,\n  'User-Agent': 'QuestionAnswerPlatform/1.0',\n  'Authorization': `QB-USER-TOKEN ${window.QUICKBASE_USER_TOKEN}`,\n  'Content-Type': 'application/json'\n});\n\n// Table IDs - Replace these with your actual QuickBase table IDs\nexport const TABLES = {\n  QUESTIONS: 'buzzze3pn',\n  ANSWERS: 'buzzzhvkj',\n  ATTACHMENTS: 'buz3i82er'\n};\n\n// Field IDs mapping by table\nexport const FIELDS = {\n  QUESTIONS: {\n    RECORD_ID: 3,\n    QUESTION: 6,\n    REQUIRED: 7,\n    FORM_ID: 10\n  },\n  ANSWERS: {\n    RECORD_ID: 3,\n    QUESTION_ID: 10,\n    ANSWER: 6,\n    USER_ID: 7,\n    USER_EMAIL: 8,\n    REQUEST_ID: 12\n  },\n  ATTACHMENTS: {\n    RECORD_ID: 3,\n    ANSWER_ID: 6,\n    FILE_ATTACHMENT: 7\n  }\n};\n\n// Types for file attachment data\n\n// API functions\nexport const api = {\n  // Get all active questions for a specific form\n  getQuestions: async formId => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.FORM_ID}.EX.'${formId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch questions');\n    }\n    return response.json();\n  },\n  // Get a single question\n  getQuestion: async questionId => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.RECORD_ID}.EX.'${questionId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch question');\n    }\n    return response.json();\n  },\n  // Get an answer for a specific question and request\n  getAnswer: async (questionId, requestId) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.RECORD_ID, FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.USER_EMAIL, FIELDS.ANSWERS.USER_ID],\n        where: `{${FIELDS.ANSWERS.QUESTION_ID}.EX.'${questionId}'}AND{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch answer');\n    }\n    return response.json();\n  },\n  // Save an answer\n  saveAnswer: async (questionId, answer, userId, requestId) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.QUESTION_ID]: {\n            value: questionId\n          },\n          [FIELDS.ANSWERS.ANSWER]: {\n            value: answer\n          },\n          [FIELDS.ANSWERS.USER_ID]: {\n            value: userId\n          },\n          [FIELDS.ANSWERS.REQUEST_ID]: {\n            value: requestId\n          }\n        }]\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to save answer');\n    }\n    return response.json();\n  },\n  // Get user's progress\n  getProgress: async requestId => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.QUESTION_ID],\n        where: `{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch progress');\n    }\n    return response.json();\n  },\n  // Update an existing answer\n  updateAnswer: async (answerId, answer, userId, requestId) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.RECORD_ID]: {\n            value: answerId\n          },\n          [FIELDS.ANSWERS.ANSWER]: {\n            value: answer\n          },\n          [FIELDS.ANSWERS.USER_ID]: {\n            value: userId\n          },\n          [FIELDS.ANSWERS.REQUEST_ID]: {\n            value: requestId\n          }\n        }]\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to update answer');\n    }\n    return response.json();\n  },\n  // Get file attachment\n  getFileAttachment: async recordId => {\n    try {\n      const response = await fetch(`${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}`, {\n        method: 'GET',\n        headers: getHeaders()\n      });\n      if (!response.ok) throw new Error('Failed to fetch file attachment');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching file attachment:', error);\n      throw error;\n    }\n  },\n  // Get attachments for an answer\n  getAttachmentsForAnswer: async answerId => {\n    try {\n      const response = await fetch(`${QB_API_URL}/records/query`, {\n        method: 'POST',\n        headers: getHeaders(),\n        body: JSON.stringify({\n          from: TABLES.ATTACHMENTS,\n          select: [FIELDS.ATTACHMENTS.RECORD_ID, FIELDS.ATTACHMENTS.FILE_ATTACHMENT],\n          where: `{${FIELDS.ATTACHMENTS.ANSWER_ID}.EX.'${answerId}'}`\n        })\n      });\n      if (!response.ok) throw new Error('Failed to fetch attachments');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching attachments:', error);\n      throw error;\n    }\n  },\n  // Upload or update file attachment\n  uploadFileAttachment: async (answerId, fileName, fileContent, recordId) => {\n    try {\n      // Convert file content to Base64 if it's a File object\n      let base64Content;\n      if (fileContent instanceof File) {\n        const buffer = await fileContent.arrayBuffer();\n        base64Content = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n      } else {\n        base64Content = fileContent; // Assume it's already Base64 encoded if it's a string\n      }\n      const data = {\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          [FIELDS.ATTACHMENTS.FILE_ATTACHMENT]: {\n            value: {\n              fileName,\n              data: base64Content\n            }\n          },\n          [FIELDS.ATTACHMENTS.ANSWER_ID]: {\n            value: answerId\n          }\n        }]\n      };\n      const url = recordId ? `${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}` : `${QB_API_URL}/records`;\n      const response = await fetch(url, {\n        method: recordId ? 'PUT' : 'POST',\n        headers: getHeaders(),\n        body: JSON.stringify(data)\n      });\n      if (!response.ok) throw new Error('Failed to upload file attachment');\n    } catch (error) {\n      console.error('Error uploading file attachment:', error);\n      throw error;\n    }\n  },\n  // Download file attachment\n  downloadFileAttachment: async url => {\n    try {\n      var _contentDisposition$s;\n      const response = await fetch(`${QB_API_URL}${url}`, {\n        method: 'GET',\n        headers: getHeaders()\n      });\n      if (!response.ok) throw new Error('Failed to download file attachment');\n      const contentDisposition = response.headers.get('Content-Disposition');\n      const fileName = (contentDisposition === null || contentDisposition === void 0 ? void 0 : (_contentDisposition$s = contentDisposition.split('filename=')[1]) === null || _contentDisposition$s === void 0 ? void 0 : _contentDisposition$s.replace(/\"/g, '')) || 'downloaded_file';\n      const content = await response.text(); // Base64 encoded content\n      return {\n        fileName,\n        content\n      };\n    } catch (error) {\n      console.error('Error downloading file attachment:', error);\n      throw error;\n    }\n  },\n  // Delete an attachment\n  deleteAttachment: async recordId => {\n    try {\n      const response = await fetch(`${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}`, {\n        method: 'DELETE',\n        headers: getHeaders()\n      });\n      if (!response.ok) throw new Error('Failed to delete attachment');\n    } catch (error) {\n      console.error('Error deleting attachment:', error);\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["QB_API_URL","getHeaders","window","QUICKBASE_REALM","QUICKBASE_USER_TOKEN","TABLES","QUESTIONS","ANSWERS","ATTACHMENTS","FIELDS","RECORD_ID","QUESTION","REQUIRED","FORM_ID","QUESTION_ID","ANSWER","USER_ID","USER_EMAIL","REQUEST_ID","ANSWER_ID","FILE_ATTACHMENT","api","getQuestions","formId","response","fetch","method","headers","body","JSON","stringify","from","select","where","ok","error","json","Error","message","getQuestion","questionId","getAnswer","requestId","saveAnswer","answer","userId","to","data","value","getProgress","updateAnswer","answerId","getFileAttachment","recordId","console","getAttachmentsForAnswer","uploadFileAttachment","fileName","fileContent","base64Content","File","buffer","arrayBuffer","btoa","String","fromCharCode","Uint8Array","url","downloadFileAttachment","_contentDisposition$s","contentDisposition","get","split","replace","content","text","deleteAttachment"],"sources":["/home/ben/lighthouse/work_requsts/frontend/src/config/quickbase.ts"],"sourcesContent":["// QuickBase API configuration\nconst QB_API_URL = 'https://api.quickbase.com/v1';\n\n// Headers for QuickBase API requests\nconst getHeaders = () => ({\n  'QB-Realm-Hostname': window.QUICKBASE_REALM,\n  'User-Agent': 'QuestionAnswerPlatform/1.0',\n  'Authorization': `QB-USER-TOKEN ${window.QUICKBASE_USER_TOKEN}`,\n  'Content-Type': 'application/json'\n});\n\n// Table IDs - Replace these with your actual QuickBase table IDs\nexport const TABLES = {\n  QUESTIONS: 'buzzze3pn',\n  ANSWERS: 'buzzzhvkj',\n  ATTACHMENTS: 'buz3i82er'\n};\n\n// Field IDs mapping by table\nexport const FIELDS = {\n  QUESTIONS: {\n    RECORD_ID: 3,\n    QUESTION: 6,\n    REQUIRED: 7,\n    FORM_ID: 10\n  },\n  ANSWERS: {\n    RECORD_ID: 3,\n    QUESTION_ID: 10,\n    ANSWER: 6,\n    USER_ID: 7,\n    USER_EMAIL: 8,\n    REQUEST_ID: 12,\n  },\n  ATTACHMENTS: {\n    RECORD_ID: 3,\n    ANSWER_ID: 6,\n    FILE_ATTACHMENT: 7\n  }\n};\n\n// Types for file attachment data\ninterface FileVersion {\n  versionNumber: number;\n  fileName: string;\n  uploaded: string;\n  creator: {\n    email: string;\n    id: string;\n    name: string;\n    userName: string;\n  };\n}\n\ninterface FileAttachment {\n  url: string;\n  reservedBy?: {\n    email: string;\n    id: string;\n    name: string;\n    userName: string;\n  };\n  versions: FileVersion[];\n}\n\ninterface FileAttachmentValue {\n  value: FileAttachment;\n}\n\ninterface Attachment {\n  record_id: number;\n  [key: number]: {\n    value: {\n      fileName: string;\n      data: string;\n    };\n  };\n}\n\n// API functions\nexport const api = {\n  // Get all active questions for a specific form\n  getQuestions: async (formId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.FORM_ID}.EX.'${formId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch questions');\n    }\n\n    return response.json();\n  },\n\n  // Get a single question\n  getQuestion: async (questionId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.RECORD_ID}.EX.'${questionId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch question');\n    }\n\n    return response.json();\n  },\n\n  // Get an answer for a specific question and request\n  getAnswer: async (questionId: string, requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.RECORD_ID, FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.USER_EMAIL, FIELDS.ANSWERS.USER_ID],\n        where: `{${FIELDS.ANSWERS.QUESTION_ID}.EX.'${questionId}'}AND{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch answer');\n    }\n\n    return response.json();\n  },\n\n  // Save an answer\n  saveAnswer: async (questionId: string, answer: string, userId: string, requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.QUESTION_ID]: { value: questionId },\n          [FIELDS.ANSWERS.ANSWER]: { value: answer },\n          [FIELDS.ANSWERS.USER_ID]: { value: userId },\n          [FIELDS.ANSWERS.REQUEST_ID]: { value: requestId }\n        }]\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to save answer');\n    }\n\n    return response.json();\n  },\n\n  // Get user's progress\n  getProgress: async (requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.QUESTION_ID],\n        where: `{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch progress');\n    }\n\n    return response.json();\n  },\n\n  // Update an existing answer\n  updateAnswer: async (answerId: string, answer: string, userId: string, requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.RECORD_ID]: { value: answerId },\n          [FIELDS.ANSWERS.ANSWER]: { value: answer },\n          [FIELDS.ANSWERS.USER_ID]: { value: userId },\n          [FIELDS.ANSWERS.REQUEST_ID]: { value: requestId }\n        }]\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to update answer');\n    }\n\n    return response.json();\n  },\n\n  // Get file attachment\n  getFileAttachment: async (recordId: number): Promise<FileAttachmentValue> => {\n    try {\n      const response = await fetch(`${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}`, {\n        method: 'GET',\n        headers: getHeaders()\n      });\n      if (!response.ok) throw new Error('Failed to fetch file attachment');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching file attachment:', error);\n      throw error;\n    }\n  },\n\n  // Get attachments for an answer\n  getAttachmentsForAnswer: async (answerId: number): Promise<{ data: Attachment[] }> => {\n    try {\n      const response = await fetch(`${QB_API_URL}/records/query`, {\n        method: 'POST',\n        headers: getHeaders(),\n        body: JSON.stringify({\n          from: TABLES.ATTACHMENTS,\n          select: [FIELDS.ATTACHMENTS.RECORD_ID, FIELDS.ATTACHMENTS.FILE_ATTACHMENT],\n          where: `{${FIELDS.ATTACHMENTS.ANSWER_ID}.EX.'${answerId}'}`\n        })\n      });\n\n      if (!response.ok) throw new Error('Failed to fetch attachments');\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching attachments:', error);\n      throw error;\n    }\n  },\n\n  // Upload or update file attachment\n  uploadFileAttachment: async (answerId: number, fileName: string, fileContent: string | File, recordId?: number): Promise<void> => {\n    try {\n      // Convert file content to Base64 if it's a File object\n      let base64Content: string;\n      if (fileContent instanceof File) {\n        const buffer = await fileContent.arrayBuffer();\n        base64Content = btoa(String.fromCharCode(...new Uint8Array(buffer)));\n      } else {\n        base64Content = fileContent; // Assume it's already Base64 encoded if it's a string\n      }\n\n      const data = {\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          [FIELDS.ATTACHMENTS.FILE_ATTACHMENT]: {\n            value: {\n              fileName,\n              data: base64Content\n            }\n          },\n          [FIELDS.ATTACHMENTS.ANSWER_ID]: { value: answerId }\n        }]\n      };\n\n      const url = recordId\n        ? `${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}`\n        : `${QB_API_URL}/records`;\n\n      const response = await fetch(url, {\n        method: recordId ? 'PUT' : 'POST',\n        headers: getHeaders(),\n        body: JSON.stringify(data)\n      });\n\n      if (!response.ok) throw new Error('Failed to upload file attachment');\n    } catch (error) {\n      console.error('Error uploading file attachment:', error);\n      throw error;\n    }\n  },\n\n  // Download file attachment\n  downloadFileAttachment: async (url: string): Promise<{ fileName: string; content: string }> => {\n    try {\n      const response = await fetch(`${QB_API_URL}${url}`, {\n        method: 'GET',\n        headers: getHeaders()\n      });\n\n      if (!response.ok) throw new Error('Failed to download file attachment');\n\n      const contentDisposition = response.headers.get('Content-Disposition');\n      const fileName = contentDisposition?.split('filename=')[1]?.replace(/\"/g, '') || 'downloaded_file';\n\n      const content = await response.text(); // Base64 encoded content\n      return { fileName, content };\n    } catch (error) {\n      console.error('Error downloading file attachment:', error);\n      throw error;\n    }\n  },\n\n  // Delete an attachment\n  deleteAttachment: async (recordId: number): Promise<void> => {\n    try {\n      const response = await fetch(`${QB_API_URL}/records/${TABLES.ATTACHMENTS}/${recordId}`, {\n        method: 'DELETE',\n        headers: getHeaders()\n      });\n\n      if (!response.ok) throw new Error('Failed to delete attachment');\n    } catch (error) {\n      console.error('Error deleting attachment:', error);\n      throw error;\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}