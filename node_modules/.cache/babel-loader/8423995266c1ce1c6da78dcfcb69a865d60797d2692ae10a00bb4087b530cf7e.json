{"ast":null,"code":"// QuickBase API configuration\nconst QB_API_URL = 'https://api.quickbase.com/v1';\n\n// Headers for QuickBase API requests\nconst getHeaders = () => ({\n  'QB-Realm-Hostname': window.QUICKBASE_REALM,\n  'User-Agent': 'QuestionAnswerPlatform/1.0',\n  'Authorization': `QB-USER-TOKEN ${window.QUICKBASE_USER_TOKEN}`,\n  'Content-Type': 'application/json'\n});\n\n// Table IDs - Replace these with your actual QuickBase table IDs\nexport const TABLES = {\n  QUESTIONS: 'buzzze3pn',\n  ANSWERS: 'buzzzhvkj',\n  ATTACHMENTS: 'buz3i82er'\n};\n\n// Field IDs mapping by table\nexport const FIELDS = {\n  QUESTIONS: {\n    RECORD_ID: 3,\n    QUESTION: 6,\n    REQUIRED: 7,\n    FORM_ID: 10\n  },\n  ANSWERS: {\n    RECORD_ID: 3,\n    QUESTION_ID: 1,\n    ANSWER: 11,\n    USER_ID: 7,\n    REQUEST_ID: 12,\n    ATTACHMENT_ID: 13\n  },\n  ATTACHMENTS: {\n    RECORD_ID: 3,\n    ANSWER_ID: 1,\n    FILE_NAME: 6,\n    FILE_TYPE: 7,\n    FILE_SIZE: 8,\n    FILE_CONTENT: 9\n  }\n};\n\n// API functions\nexport const api = {\n  // Get all active questions for a specific form\n  getQuestions: async formId => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.FORM_ID}.EX.'${formId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch questions');\n    }\n    return response.json();\n  },\n  // Get a single question\n  getQuestion: async questionId => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.RECORD_ID}.EX.'${questionId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch question');\n    }\n    return response.json();\n  },\n  // Save an answer\n  saveAnswer: async (questionId, answer, userId, requestId) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.QUESTION_ID]: {\n            value: questionId\n          },\n          [FIELDS.ANSWERS.ANSWER]: {\n            value: answer\n          },\n          [FIELDS.ANSWERS.USER_ID]: {\n            value: userId\n          },\n          [FIELDS.ANSWERS.REQUEST_ID]: {\n            value: requestId\n          }\n        }]\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to save answer');\n    }\n    return response.json();\n  },\n  // Upload an attachment\n  uploadAttachment: async (answerId, file) => {\n    // First, create the attachment record\n    const createResponse = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          [FIELDS.ATTACHMENTS.ANSWER_ID]: {\n            value: answerId\n          },\n          [FIELDS.ATTACHMENTS.FILE_NAME]: {\n            value: file.name\n          },\n          [FIELDS.ATTACHMENTS.FILE_TYPE]: {\n            value: file.type\n          },\n          [FIELDS.ATTACHMENTS.FILE_SIZE]: {\n            value: file.size\n          }\n        }]\n      })\n    });\n    if (!createResponse.ok) {\n      const error = await createResponse.json();\n      throw new Error(error.message || 'Failed to create attachment record');\n    }\n    const {\n      data: [{\n        record_id\n      }]\n    } = await createResponse.json();\n\n    // Then, upload the file content\n    const fileContent = await file.arrayBuffer();\n    const uploadResponse = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          [FIELDS.ATTACHMENTS.RECORD_ID]: {\n            value: record_id\n          },\n          [FIELDS.ATTACHMENTS.FILE_CONTENT]: {\n            value: fileContent\n          }\n        }]\n      })\n    });\n    if (!uploadResponse.ok) {\n      const error = await uploadResponse.json();\n      throw new Error(error.message || 'Failed to upload file content');\n    }\n    return uploadResponse.json();\n  },\n  // Get user's progress\n  getProgress: async requestId => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.QUESTION_ID],\n        where: `{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch progress');\n    }\n    return response.json();\n  },\n  // Get an answer for a specific question, user, and request\n  getAnswer: async (questionId, userId, requestId) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.RECORD_ID, FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.ATTACHMENT_ID],\n        where: `{${FIELDS.ANSWERS.QUESTION_ID}.EX.'${questionId}'}AND{${FIELDS.ANSWERS.USER_ID}.EX.'${userId}'}AND{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch answer');\n    }\n    return response.json();\n  },\n  // Update an existing answer\n  updateAnswer: async (answerId, answer, userId, requestId) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.RECORD_ID]: {\n            value: answerId\n          },\n          [FIELDS.ANSWERS.ANSWER]: {\n            value: answer\n          },\n          [FIELDS.ANSWERS.USER_ID]: {\n            value: userId\n          },\n          [FIELDS.ANSWERS.REQUEST_ID]: {\n            value: requestId\n          }\n        }]\n      })\n    });\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to update answer');\n    }\n    return response.json();\n  }\n};","map":{"version":3,"names":["QB_API_URL","getHeaders","window","QUICKBASE_REALM","QUICKBASE_USER_TOKEN","TABLES","QUESTIONS","ANSWERS","ATTACHMENTS","FIELDS","RECORD_ID","QUESTION","REQUIRED","FORM_ID","QUESTION_ID","ANSWER","USER_ID","REQUEST_ID","ATTACHMENT_ID","ANSWER_ID","FILE_NAME","FILE_TYPE","FILE_SIZE","FILE_CONTENT","api","getQuestions","formId","response","fetch","method","headers","body","JSON","stringify","from","select","where","ok","error","json","Error","message","getQuestion","questionId","saveAnswer","answer","userId","requestId","to","data","value","uploadAttachment","answerId","file","createResponse","name","type","size","record_id","fileContent","arrayBuffer","uploadResponse","getProgress","getAnswer","updateAnswer"],"sources":["/home/ben/lighthouse/work_requsts/frontend/src/config/quickbase.ts"],"sourcesContent":["// QuickBase API configuration\nconst QB_API_URL = 'https://api.quickbase.com/v1';\n\n// Headers for QuickBase API requests\nconst getHeaders = () => ({\n  'QB-Realm-Hostname': window.QUICKBASE_REALM,\n  'User-Agent': 'QuestionAnswerPlatform/1.0',\n  'Authorization': `QB-USER-TOKEN ${window.QUICKBASE_USER_TOKEN}`,\n  'Content-Type': 'application/json'\n});\n\n// Table IDs - Replace these with your actual QuickBase table IDs\nexport const TABLES = {\n  QUESTIONS: 'buzzze3pn',\n  ANSWERS: 'buzzzhvkj',\n  ATTACHMENTS: 'buz3i82er'\n};\n\n// Field IDs mapping by table\nexport const FIELDS = {\n  QUESTIONS: {\n    RECORD_ID: 3,\n    QUESTION: 6,\n    REQUIRED: 7,\n    FORM_ID: 10\n  },\n  ANSWERS: {\n    RECORD_ID: 3,\n    QUESTION_ID: 1,\n    ANSWER: 11,\n    USER_ID: 7,\n    REQUEST_ID: 12,\n    ATTACHMENT_ID: 13\n  },\n  ATTACHMENTS: {\n    RECORD_ID: 3,\n    ANSWER_ID: 1,\n    FILE_NAME: 6,\n    FILE_TYPE: 7,\n    FILE_SIZE: 8,\n    FILE_CONTENT: 9\n  }\n};\n\n// API functions\nexport const api = {\n  // Get all active questions for a specific form\n  getQuestions: async (formId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.FORM_ID}.EX.'${formId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch questions');\n    }\n\n    return response.json();\n  },\n\n  // Get a single question\n  getQuestion: async (questionId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.QUESTIONS,\n        select: [FIELDS.QUESTIONS.RECORD_ID, FIELDS.QUESTIONS.QUESTION, FIELDS.QUESTIONS.REQUIRED],\n        where: `{${FIELDS.QUESTIONS.RECORD_ID}.EX.'${questionId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch question');\n    }\n\n    return response.json();\n  },\n\n  // Save an answer\n  saveAnswer: async (questionId: string, answer: string, userId: string, requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.QUESTION_ID]: { value: questionId },\n          [FIELDS.ANSWERS.ANSWER]: { value: answer },\n          [FIELDS.ANSWERS.USER_ID]: { value: userId },\n          [FIELDS.ANSWERS.REQUEST_ID]: { value: requestId }\n        }]\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to save answer');\n    }\n\n    return response.json();\n  },\n\n  // Upload an attachment\n  uploadAttachment: async (answerId: string, file: File) => {\n    // First, create the attachment record\n    const createResponse = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          [FIELDS.ATTACHMENTS.ANSWER_ID]: { value: answerId },\n          [FIELDS.ATTACHMENTS.FILE_NAME]: { value: file.name },\n          [FIELDS.ATTACHMENTS.FILE_TYPE]: { value: file.type },\n          [FIELDS.ATTACHMENTS.FILE_SIZE]: { value: file.size }\n        }]\n      })\n    });\n\n    if (!createResponse.ok) {\n      const error = await createResponse.json();\n      throw new Error(error.message || 'Failed to create attachment record');\n    }\n\n    const { data: [{ record_id }] } = await createResponse.json();\n\n    // Then, upload the file content\n    const fileContent = await file.arrayBuffer();\n    const uploadResponse = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ATTACHMENTS,\n        data: [{\n          [FIELDS.ATTACHMENTS.RECORD_ID]: { value: record_id },\n          [FIELDS.ATTACHMENTS.FILE_CONTENT]: { value: fileContent }\n        }]\n      })\n    });\n\n    if (!uploadResponse.ok) {\n      const error = await uploadResponse.json();\n      throw new Error(error.message || 'Failed to upload file content');\n    }\n\n    return uploadResponse.json();\n  },\n\n  // Get user's progress\n  getProgress: async (requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.QUESTION_ID],\n        where: `{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch progress');\n    }\n\n    return response.json();\n  },\n\n  // Get an answer for a specific question, user, and request\n  getAnswer: async (questionId: string, userId: string, requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records/query`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        from: TABLES.ANSWERS,\n        select: [FIELDS.ANSWERS.RECORD_ID, FIELDS.ANSWERS.ANSWER, FIELDS.ANSWERS.ATTACHMENT_ID],\n        where: `{${FIELDS.ANSWERS.QUESTION_ID}.EX.'${questionId}'}AND{${FIELDS.ANSWERS.USER_ID}.EX.'${userId}'}AND{${FIELDS.ANSWERS.REQUEST_ID}.EX.'${requestId}'}`\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to fetch answer');\n    }\n\n    return response.json();\n  },\n\n  // Update an existing answer\n  updateAnswer: async (answerId: string, answer: string, userId: string, requestId: string) => {\n    const response = await fetch(`${QB_API_URL}/records`, {\n      method: 'POST',\n      headers: getHeaders(),\n      body: JSON.stringify({\n        to: TABLES.ANSWERS,\n        data: [{\n          [FIELDS.ANSWERS.RECORD_ID]: { value: answerId },\n          [FIELDS.ANSWERS.ANSWER]: { value: answer },\n          [FIELDS.ANSWERS.USER_ID]: { value: userId },\n          [FIELDS.ANSWERS.REQUEST_ID]: { value: requestId }\n        }]\n      })\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.message || 'Failed to update answer');\n    }\n\n    return response.json();\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}